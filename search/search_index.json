{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"code-reviews/","title":"Code Reviews","text":"<p>LLMs can produce non-factual or irrelevant output (hallucinations). In software development, that translates into risky code changes and extra engineering overhead:</p> <ul> <li>Difficulty programmatically trusting AI-generated code.</li> <li>Increased complexity in error handling and QA.</li> <li>Potential for cascading failures in chained AI operations.</li> <li>Manual review cycles that slow development and deployment.</li> </ul> <p>Code Reviews is part of kluster.ai trust layer, and its goal is to validate AI-generated code in real time so you can deploy AI at scale where accuracy and security matter most.</p> <p>With Code Reviews, you can ship confidently: potential issues are surfaced (and can be auto-corrected) before they reach production. The service works seamlessly with AI coding assistants in your IDE (Cursor, VS Code, Claude Code and others), analyzing diffs as code is generated.</p>"},{"location":"code-reviews/#how-code-reviews-works","title":"How Code Reviews works","text":"<p>Code Reviews analyzes AI-generated code (typically in diff format) and returns a structured assessment with actionable fixes. It combines the following MCP tools:</p> <ul> <li><code>kluster_code_review_auto</code>: Automatic code security, quality, and compliance verification.</li> <li><code>kluster_dependency_validator</code>: Dependency health and risk validation.</li> <li><code>kluster_code_review_manual</code>: On-demand, user-requested per-file verification (security, quality, compliance).</li> </ul> <p>The service responds with the following fields:</p> <ul> <li><code>isCodeCorrect</code>: Indicates whether the code has issues.</li> <li><code>issues</code>: Array of detected problems with type, severity, and priority.</li> <li><code>explanation</code>: Summary of all issues found.</li> <li><code>agent_todo_list</code>: Prioritized list of fixes to apply.</li> </ul>"},{"location":"code-reviews/#key-features","title":"Key features","text":"<ul> <li>Real-time code review: Monitors AI-generated code as it\u2019s written.</li> <li>Comprehensive issue detection: Analyzes 7 issue types \u2014 Semantic, Intent, Logical, Security, Knowledge, Performance, and Quality.</li> <li>Customizable sensitivity levels: Configure detection sensitivity from Low to Critical.</li> <li>Dual analysis tools: Real-time Code Review and Dependency Analysis for complete coverage.</li> <li>Automatic correction: AI incorporates feedback to fix issues immediately.</li> </ul>"},{"location":"code-reviews/#configuration-options","title":"Configuration options","text":"<p>Tailor Code Reviews to your workflow:</p> <ul> <li>Sensitivity settings: Set minimum sensitivity to report (Low \u2192 Critical).</li> <li>Bug check types: Select which issue types to check: Semantic, Security, Quality, Intent, Knowledge, Logical, Performance.</li> <li>Enabled tools: Choose which MCP tools are active (bug check tool, packages check tool).</li> </ul> <p>These settings can be configured directly in your IDE integration.</p>"},{"location":"code-reviews/#target-applications-and-use-cases","title":"Target applications and use cases","text":"<ul> <li>AI coding assistants and IDE integrations.</li> <li>Automated code review pipelines.</li> <li>CI/CD security scanning for AI-generated code.</li> <li>Development workflow automation.</li> <li>Code quality assurance systems.</li> </ul>"},{"location":"code-reviews/#when-to-use-code-reviews","title":"When to use Code Reviews","text":"<ul> <li>AI code validation: Review AI-generated code before production use.</li> <li>Security scanning: Detect potential vulnerabilities early.</li> <li>Quality assurance: Enforce best practices automatically.</li> <li>Dependency checking: Validate that new packages are secure and up-to-date.</li> </ul>"},{"location":"code-reviews/#setup-instructions","title":"Setup instructions","text":"<p>Code Reviews is available as a native extension for IDEs such as Cursor, VS Code and Claude Code. Choose your preferred IDE to get started with kluster.ai Code Reviews in under 30 seconds:</p> <ul> <li> <p> Cursor</p> <p>Install the extension directly from the Cursor marketplace.</p> <p> Add to Cursor</p> </li> <li> <p> VS Code</p> <p>Install the extension directly from the VS Code marketplace.</p> <p> Add to VS Code</p> </li> <li> <p> Claude Code</p> <p>Run a simple script in your terminal to set up Code Reviews quickly.</p> <p> Install Claude Code</p> </li> </ul>"},{"location":"code-reviews/#additional-resources","title":"Additional resources","text":"<ul> <li>Get started: Run Code Reviews in minutes.</li> <li>See real examples: Walk through a complete Firebase migration case study.</li> </ul>"},{"location":"code-reviews/quickstart/","title":"Get started with Code Reviews","text":"<p>Modern developers increasingly rely on AI coding assistants to accelerate development, but this speed comes with risks. Generated code may contain logic errors, security flaws, or performance issues that compromise application quality and security.</p> <p>The kluster.ai Code reviews service integrates directly into your development workflow, automatically scanning AI-generated code in real-time. It catches potential issues instantly within your IDE, allowing you to ship code confidently while maintaining the speed benefits of AI-assisted development.</p>"},{"location":"code-reviews/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before getting started, ensure you have:</p> <ul> <li>A kluster.ai account: Sign up on the kluster.ai platform if you don't have one.</li> </ul> <p>As kluster.ai services work via MCP, the API key is created and configured for you when setting up the relevant extensions.</p>"},{"location":"code-reviews/quickstart/#setup-instructions","title":"Setup instructions","text":"CursorVS CodeClaude Code <ol> <li> <p>Click the Add to Cursor button below.</p> <p> Add to Cursor</p> </li> <li> <p>Cursor will open and prompt for extension installation.</p> </li> <li> <p>Click Install to add the extension into Cursor.</p> <p></p> </li> </ol> <p>Once installed, you can verify the setup:</p> <ol> <li>Open Cursor Settings. You can use the gear icon in the top right corner to do so.</li> <li>Navigate to Tools &amp; Integrations \u2192 MCP Tools.</li> <li> <p>You should see extension-Kluster-Code-Reviews with all tools enabled:</p> <ul> <li><code>kluster_code_review_auto</code>: Automatic code security, quality, and compliance verification.</li> <li><code>kluster_dependency_validator</code>: Dependency health and risk validation.</li> <li><code>kluster_code_review_manual</code>: On-demand, user-requested per-file verification (security, quality, compliance).</li> </ul> <p></p> </li> </ol> <ol> <li> <p>Click the Add to VS Code button below: </p> <p> Add to VS Code</p> </li> <li> <p>VS Code will open and display the extension.</p> </li> <li> <p>Click Install to get the extension.</p> <p></p> </li> <li> <p>Select Trust Publisher &amp; Install.</p> <p></p> </li> </ol> <p>Now that the extension is installed, you need to log in with your kluster.ai account:</p> <ol> <li> <p>Click on Sign in in the bottom right corner.    </p> </li> <li> <p>Choose Open. A browser pop-up window will take you to your kluster.ai account. </p> <p></p> </li> <li> <p>Click Open Visual Studio Code.</p> <p></p> </li> <li> <p>Click Open to install the MCP with your kluster.ai API key.</p> <p></p> </li> <li> <p>To complete the setup, click Install to accept the MCP configuration for Code Reviews. </p> <p></p> </li> <li> <p>Press Trust to Install the MCP server. </p> </li> </ol> <p>Once installed, verify the setup:</p> <ol> <li>Open a Copilot chat window and select the Tools button on the bottom right corner.</li> <li> <p>Scroll down the list and Kluster-Code-Reviews-MCP should appear. Make sure both tools enabled.</p> <p></p> </li> </ol> <p>Terminal installation</p> <p>Visit the kluster.ai platform get started page and copy the Claude Code configuration snippet. This will include your API key.</p> <p>The command is similar to:</p> <pre><code>curl -s https://platform.kluster.ai/install-kluster-mcp-claude-code.sh | bash -s YOUR_API_KEY\n</code></pre> <p>This command will:</p> <ul> <li>Download the kluster.ai MCP server.</li> <li>Configure Claude Code settings.</li> <li>Set up your API key.</li> <li>Enable both verification tools.</li> </ul> <p> franzuzz@MacBook-Pro-de-Jean mcp-demo % curl -s https://platform.kluster.ai/install-kluster-mcp-claude-code.sh | bash -s YOUR_API_KEY Installing Kluster.ai server... \u2705 Installation complete! Restart Claude Code to apply the new rules Happy {K}oding ;) </p> <p>Once installed, verify the setup:</p> <ol> <li> <p>Run the <code>/mcp</code> command in Claude Code.</p> <p> claude /mcp \u2728 Welcome to Claude Code! /help for help, /status for your current setup cwd: /Users/franzuzz/code/demos/claude-code/mcp-demo Tips for getting started: Ask Claude to create a new app or clone a repository Use Claude to help with file analysis, editing, bash commands and git Be as specific as you would with another engineer for the best results \u2714 Run /terminal-setup to set up terminal integration <p>/mcp Manage MCP servers   1. kluster-verify \u2714 connected \u2022 Enter to view details MCP Config locations (by scope):  \u2022 User config: /Users/franzuzz/.claude.json  \u2022 Project config (shared via .mcp.json):    /Users/franzuzz/code/demos/claude-code/mcp-demo/.mcp.json (file does not exist)  \u2022 Local config (private to this project):    /Users/franzuzz/.claude.json [project: /Users/franzuzz/code/demos/claude-code/mcp-demo] For help configuring MCP servers, see: https://docs.anthropic.com/en/docs/claude-code/mcp </p> <li> <p>Select kluster-code-reviews in the MCP menu list and press enter to View tools.</p> <p> Kluster-verify MCP Server Status: \u2714 connected Command: npx Args: -y @klusterai/kluster-verify-code-mcp@latest Config location: /Users/franzuzz/.claude.json Capabilities: tools Tools: 3 tools   1. View tools   2. Reconnect </p> </li> <li> <p>Select View tools to see the tools for kluster-code-reviews listed, including:</p> <ul> <li><code>kluster_code_review_auto</code>: Automatic code security, quality, and compliance verification.</li> <li><code>kluster_dependency_validator</code>: Dependency health and risk validation.</li> <li><code>kluster_code_review_manual</code>: On-demand, user-requested per-file verification (security, quality, compliance).</li> </ul> <p> Tools for kluster-verify (3 tools)   1. kluster_code_review_auto   2. kluster_dependency_validator   3. kluster_code_review_manual </p> </li>"},{"location":"code-reviews/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Cursor example: See a real-world case study using Cursor.</li> <li>VS-Code example: See a real-world case study using VS-Code.</li> </ul>"},{"location":"code-reviews/tools/","title":"Tools reference","text":"<p>The kluster.ai Code MCP server provides review tools for checking AI-generated code quality and security. These tools enable real-time code reviews directly within your IDE through MCP integration.</p> <p>It includes:</p> <ul> <li><code>kluster_code_review_auto</code>: Automatically reviews code quality and detects bugs, including logic errors, security issues, and performance problems. Triggers automatically when code is generated or modified. Best for real-time reviews during active coding sessions, analyzing changes in context of the full conversation and related files.</li> <li><code>kluster_dependency_validator</code>: Validates the security and compliance of packages and dependencies. Triggers automatically before package installations or when package files are updated. Best for preventing vulnerable or non-compliant third-party libraries from entering your codebase before installation.</li> <li><code>kluster_code_review_manual</code>: Manually reviews specific files when explicitly requested by the user (e.g., \"review this file\", \"check for bugs\"). Best for auditing existing code, reviewing specific modules, or getting fix recommendations for individual files.</li> </ul> <p>This page documents the parameters and response formats you'll see when using these tools in Cursor, Claude Code, or any MCP-compatible client.</p>"},{"location":"code-reviews/tools/#parameters","title":"Parameters","text":"Auto Review and Dependency ValidatorManual Review <p>These tools analyze AI-generated code and dependencies to detect bugs, security vulnerabilities, and other quality issues.</p> Parameters <p><code>code_diff</code> string required</p> <p>Unified diff format showing the actual changes (additions and subtractions) made to files. Use standard diff format with <code>--- filename</code> and <code>+++ filename</code> headers, followed by <code>@@ line numbers @@</code>, and <code>+</code> for additions, <code>-</code> for deletions. In MCP environments, this is often auto-extracted from IDE history.</p> <p><code>user_requests</code> string required</p> <p>A chronological sequence of all user messages and requests in this conversation thread, with the current request (that triggered this assistant turn) clearly marked. Format: Previous requests as numbered list, then current request marked with <code>&gt;&gt;&gt; CURRENT REQUEST: [request text]</code>. In MCP environments, this is often auto-extracted from conversation history.</p> <p><code>modified_files_path</code> string required</p> <p>Full absolute paths of modified files separated by <code>;</code>.</p> <p><code>chat_id</code> string optional</p> <p>Session identifier returned by previous tool calls. Used to maintain context across multiple review requests.</p> <p>The manual review tool is triggered only when explicitly requested by the user.</p> Parameters <p><code>user_requests</code> string required</p> <p>Chronological sequence of user messages with current request marked as <code>&gt;&gt;&gt; CURRENT REQUEST:</code>. Unlike auto review, this parameter is NOT auto-extracted in MCP environments and must be explicitly provided.</p> <p><code>modified_file_path</code> string required</p> <p>Full absolute path of the single file to review. This tool can only check one file per call.</p> <p><code>need_fixes</code> boolean required</p> <p>Set to <code>true</code> if user requested fixes, <code>false</code> if only requesting issue detection.</p> <p><code>chat_id</code> string optional</p> <p>Session identifier returned by previous tool calls. Used to maintain context across multiple review requests.</p>"},{"location":"code-reviews/tools/#response-fields","title":"Response fields","text":"<p>All Code review tools return the same response structure:</p> <ul> <li><code>isCodeCorrect</code>: Boolean indicating if the code has issues.</li> <li><code>explanation</code>: Summary of all issues found.</li> <li><code>issues</code>: Array of detected problems with:</li> <li><code>type</code>: Issue category (intent, semantic, knowledge, performance, quality, logical, security).</li> <li><code>severity</code>: Impact level (critical, high, medium, low).</li> <li><code>priority</code>: Execution priority (P0-P5).</li> <li><code>description</code>: Brief issue summary.</li> <li><code>explanation</code>: Detailed issue explanation.</li> <li><code>actions</code>: Recommended fixes.</li> <li><code>priority_instructions</code>: Execution rules for addressing issues.</li> <li><code>agent_todo_list</code>: Prioritized list of fixes to apply.</li> <li><code>chat_id</code>: Session identifier for maintaining context across requests.</li> </ul>"},{"location":"code-reviews/tools/#example-response","title":"Example response","text":"<pre><code>{\n    \"isCodeCorrect\": false,\n    \"explanation\": \"Found 1 issue. 1 critical issue needs immediate attention.\\n\\nTODO:\\n1. [CRITICAL] The implementation introduces a critical SQL injection vulnerability.\",\n    \"issues\": [\n        {\n            \"type\": \"intent\",\n            \"severity\": \"critical\",\n            \"priority\": \"P0\",\n            \"description\": \"The implementation introduces a critical SQL injection vulnerability, which is an unacceptable security risk.\",\n            \"explanation\": \"The code constructs an SQL query using string concatenation with user input, which is the classic pattern for SQL injection. A function designed for database interaction should use parameterized queries.\",\n            \"actions\": \"Use parameterized queries or prepared statements to safely handle user input. For example: db.query('SELECT * FROM users WHERE id = ?', [userId])\"\n        }\n    ],\n    \"priority_instructions\": \"**PRIORITY EXECUTION RULES:**\\n1. **INTENT Critical/High (P0-P1) get special priority**\\n2. **All other issues sorted by severity** - Critical (P2) &gt; High (P3) &gt; Medium (P4) &gt; Low (P5)\\n3. **Never let lower priority issues override higher priority changes**\",\n    \"agent_todo_list\": [\n        \"**EXECUTE IN THIS EXACT ORDER:**\",\n        \"\",\n        \"**Priority P0 - INTENT CRITICAL (HIGHEST PRIORITY):**\",\n        \"P0.1: The implementation introduces a critical SQL injection vulnerability - Use parameterized queries or prepared statements.\"\n    ],\n    \"chat_id\": \"i8ct930591\"\n}\n</code></pre>"},{"location":"code-reviews/tools/#priority-system","title":"Priority system","text":"<p>Code review assigns priority levels to detected issues, helping you focus on the most critical problems first. The system automatically prioritizes based on issue type and severity.</p> <ul> <li>P0-P1: Intent issues (highest priority) - code doesn't match request.</li> <li>P2: Critical severity - must fix immediately.</li> <li>P3: High severity - should fix soon.</li> <li>P4: Medium severity - nice to fix.</li> <li>P5: Low severity - optional improvements.</li> </ul>"},{"location":"code-reviews/tools/#next-steps","title":"Next steps","text":"<ul> <li>Configure settings: Customize review behavior for your needs.</li> <li>Set up integrations: Configure IDE integrations to use these tools.</li> <li>Get started: Follow the quickstart guide for immediate setup.</li> </ul>"},{"location":"code-reviews/configuration/options/","title":"Options","text":"<p>You can customize the kluster.ai Code reviews behavior through the platform settings or directly in your IDE. This allows you to tailor the review process to your specific needs, such as configuring sensitivity levels for issue reporting, selecting which types of bug checks to perform, and enabling or disabling specific MCP tools to match your development workflow.</p> <p></p>"},{"location":"code-reviews/configuration/options/#1-sensitivity-settings","title":"1. Sensitivity settings","text":"<p>Configure the minimum sensitivity level for the Real-time Code Review tool's issue reporting. Set your threshold based on your team's needs:</p> <ul> <li><code>Low</code>: Detects even the smallest potential issues.</li> <li><code>Medium</code>: Suitable for projects requiring strong security and high code quality.</li> <li><code>High</code>: (Recommended) Balances strong protection against LLM hallucination and security issues with performance.</li> <li><code>Critical</code>: Focuses only on critical issues for faster iteration and smoother coding experience.</li> </ul> <p>The ideal setting depends on your use case. For example, a High level is a good starting point, but you might want to set it to Medium for production code.</p>"},{"location":"code-reviews/configuration/options/#2-code-review-scope","title":"2. Code review scope","text":"<p>Select which types of issues the Real-time Code Review tool detects during code analysis. You have full control over which bug types to check for through simple on/off toggles.</p> Type Description Example <code>intent</code> Code doesn't match user request User asked for sorting, got filtering <code>semantic</code> Logic errors Missing error handling <code>knowledge</code> Best practice violations Not following conventions <code>performance</code> Performance issues Inefficient algorithms <code>quality</code> Code quality problems Poor naming, complexity <code>logical</code> Logic errors Off-by-one errors <code>security</code> Security vulnerabilities SQL injection risks"},{"location":"code-reviews/configuration/options/#3-enabled-tools","title":"3. Enabled tools","text":"<p>Control which review tools run in your development environment. Enable or disable each tool based on your project's specific needs and workflow.</p> <ul> <li><code>Real-time Code Review</code>: For code quality reviews.</li> <li><code>Dependency Analysis</code>: For package and dependency security.</li> </ul>"},{"location":"code-reviews/configuration/options/#next-steps","title":"Next steps","text":"<ul> <li>Create custom rules: Add project-specific development standards.</li> <li>View tools reference: Understand the technical API details.</li> <li>Set up integrations: Configure IDE integrations.</li> </ul>"},{"location":"code-reviews/configuration/rules/","title":"Custom rules","text":"<p>Rules define practices, guidelines, and patterns that maintain code quality for your projects. When connected to GitHub, each repository becomes a project with its own learned rules. You can also create manual rules that apply globally or to specific projects. kluster.ai Code reviews automatically checks newly generated code against these rules.</p>"},{"location":"code-reviews/configuration/rules/#rule-types","title":"Rule types","text":"<ul> <li>Manual rules: Custom rules you create based on your team's specific requirements and coding standards.</li> <li>Learned rules: Automatically extracted from your GitHub repositories, continuously updated to reflect your codebase patterns.</li> </ul>"},{"location":"code-reviews/configuration/rules/#set-up-instructions","title":"Set up instructions","text":"<p>You can create manual rules to enforce your team's coding standards or connect GitHub to automatically extract patterns from your repositories. Rules can be applied globally or to specific projects.</p> <p>Extraction rate limit</p> <p>Rule extraction from repositories is limited to once per hour. Wait 60 minutes between extraction requests.</p> <ol> <li> <p>Access the platform: Navigate to Custom Code Review Rules.</p> </li> <li> <p>Connect GitHub (Optional): Connect your GitHub account to enable project-specific rules. In this context, each GitHub repository is treated as a 'project' - Code reviews learns patterns from each repository and applies those specific rules when reviewing code for that project.</p> <p></p> </li> <li> <p>Click Add review rule to create custom rules.</p> <p></p> </li> <li> <p>Configure rule scope: Enter your rule and select the scope:</p> <ul> <li>All: Rules apply globally to all your coding sessions.</li> <li>Project-specific: Select a repository from the dropdown (requires GitHub connection).</li> </ul> </li> <li> <p>Click Save &amp; Add Another to add multiple rules or Save to finish.</p> <p></p> </li> </ol>"},{"location":"code-reviews/configuration/rules/#next-steps","title":"Next steps","text":"<ul> <li>View all integrations: Set up Code reviews in your preferred IDE.</li> <li>See real examples: Walk through a complete Firebase migration case study.</li> </ul>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/","title":"Cursor: Firebase authentication","text":"<p>Learn how Code Reviews acts as your safety net when using Cursor AI to write code. This tutorial demonstrates a real migration from localStorage to Firebase authentication in a buy-sell e-commerce platform, showcasing how AI plans can go wrong and the four critical issues Code Reviews caught.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#prerequisites","title":"Prerequisites","text":"<ul> <li>A kluster.ai account: Sign up on the kluster.ai platform if you don't have one.</li> </ul> <p>As kluster.ai services work via MCP, the API key is created and configured for you when setting up the relevant extensions.</p> <ul> <li>Cursor IDE installed</li> </ul>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#setup","title":"Setup","text":"<p>Getting Code Reviews working in Cursor takes just one click. Visit our quickstart guide and click Add to Cursor for automatic installation.</p> <p>For other IDEs, see our MCP-compatible integration guides.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#nextjs-e-commerce","title":"Next.js e-commerce","text":"<p>We built a buy-sell e-commerce platform where users post articles for purchase. The app initially used <code>localStorage</code> for user authentication, but we decided to migrate to Firebase for better security and user management.</p> <p>We used Gemini 2.5 Flash (Cursor's standard free model) in agentic mode to handle the migration while Code Reviews monitored the changes.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#the-prompt-and-ais-plan","title":"The prompt and AI's plan","text":"<p>Our prompt was to implement a real user login with Firebase + Firebase default app setting file.</p> <p></p> <p>The AI responded confidently with a detailed 5-step plan:</p> <ol> <li>Create Firebase initialization file: Set up <code>src/lib/firebase.ts</code>.</li> <li>Install Firebase: Add the npm package.</li> <li>Update authentication context: Modify <code>src/contexts/AuthContext.tsx</code>.</li> <li>Update Login API route: Handle Firebase in <code>src/app/api/auth/login/route.ts</code>.</li> <li>Update Signup API route: Handle Firebase in <code>src/app/api/auth/signup/route.ts</code>.</li> </ol>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#plan-vs-implementation-outcomes","title":"Plan vs. implementation outcomes","text":"<p>The AI's 5-step implementation plan achieved just 20% success rate, with four critical failures.</p> Step Task Result 1 Firebase initialization \u274c Failed - Incomplete implementation 2 Install Firebase \u2705 Success 3 Update AuthContext \u274c Failed - Architecture regression 4 Update login API \u274c Failed - Breaking changes 5 Update signup API \u274c Failed - Security vulnerabilities <p>The AI got confused between steps 3-4, couldn't decide between direct Firebase calls vs API routes, kept reverting working code, and made multiple correction attempts throughout the implementation.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#key-issues-caught-by-code-reviews","title":"Key issues caught by Code Reviews","text":"<p>The AI made four key mistakes along the way, escalating from simple import issues to reverting the entire Firebase implementation. Below, we examine each catch.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#incomplete-implementation","title":"Incomplete implementation","text":"<p>What happened? AI created Firebase config but missed the actual authentication setup.</p> <pre><code>// src/lib/firebase.ts - Step 1 attempt\nimport { initializeApp } from \"firebase/app\";\nimport { getAnalytics } from \"firebase/analytics\";\n\nconst firebaseConfig = { /* config */ };\nconst app = initializeApp(firebaseConfig);\nconst analytics = getAnalytics(app); // \u274c No auth setup\n</code></pre> <p>Code Reviews provided the following response:</p> <p>P1 - Intent (High): AI did not implement the actual user login functionality as requested.</p> <p>Why this matters: Running the app would cause runtime errors when trying to authenticate - the <code>auth</code> object simply doesn't exist.</p> <p>Correct approach: <pre><code>// src/lib/firebase.ts - Corrected\nimport { initializeApp } from \"firebase/app\";\nimport { getAnalytics } from \"firebase/analytics\";\nimport { getAuth } from \"firebase/auth\"; // \u2705 Added\n\nconst firebaseConfig = { /* config */ };\nconst app = initializeApp(firebaseConfig);\nconst analytics = getAnalytics(app);\nconst auth = getAuth(app); // \u2705 Initialize auth\n\nexport { app, auth, analytics }; // \u2705 Export auth\n</code></pre></p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#breaking-changes","title":"Breaking changes","text":"<p>What happened? AI removed the working Firebase login logic from the API route.</p> <pre><code>// src/app/api/auth/login/route.ts - Working version\nexport async function POST(req: NextRequest) {\n  const { email, password } = await req.json();\n  const userCredential = await signInWithEmailAndPassword(auth, email, password);\n  return NextResponse.json({ message: \"Login successful\", user: user.toJSON() });\n}\n</code></pre> <pre><code>// AI's \"fix\" - Step 4 attempt\nexport async function POST(req: NextRequest) {\n  return NextResponse.json({ message: \"Not used for direct login\" }); // \u274c Removed logic\n}\n</code></pre> <p>The screenshot below shows Cursor's interface with Code Reviews's alert panel displaying a critical P1 Intent violation. The alert clearly identifies that the AI removed working Firebase authentication logic from the login API route, replacing functional code with a placeholder response.</p> <p></p> <p>Code Reviews provided the following response:</p> <p>P1 - Intent (High): AI removed Firebase login implementation instead of maintaining it.</p> <p>Why this matters: AI replaced working authentication logic with a non-functional placeholder response, breaking the API contract.</p> <p>Correct approach: Keep the original working Firebase authentication logic.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#security-vulnerabilities","title":"Security vulnerabilities","text":"<p>What happened? AI created a signup endpoint without input validation.</p> <pre><code>// src/app/api/auth/signup/route.ts - Step 5 attempt\nexport async function POST(request: NextRequest) {\n  const body = await request.json();\n  const { email, password, name } = body; // \u274c No validation!\n\n  const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n}\n</code></pre> <p>Code Reviews provided the following response:</p> <p>P3 - Security (High): Lack of input validation for signup data.</p> <p>Why this matters: Malformed data could crash the server, invalid emails cause Firebase errors, weak passwords accepted.</p> <p>Correct approach:</p> <pre><code>import { SignupSchema } from '@/lib/validation';\n\nexport async function POST(request: NextRequest) {\n  const body = await request.json();\n\n  // \u2705 Validate input\n  const validationResult = SignupSchema.safeParse(body);\n  if (!validationResult.success) {\n    return NextResponse.json({\n      error: 'Validation failed',\n      details: validationResult.error.issues\n    }, { status: 400 });\n  }\n\n  const { email, password, name } = validationResult.data;\n  const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n}\n</code></pre>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#architecture-regression","title":"Architecture regression","text":"<p>What happened? AI reverted the Firebase authentication logic back to the <code>localStorage</code> approach.</p> <pre><code>// src/contexts/AuthContext.tsx - Correct Firebase approach\nconst login = async (email: string, password: string) =&gt; {\n  const userCredential = await signInWithEmailAndPassword(auth, email, password);\n  return !!userCredential.user;\n};\n</code></pre> <pre><code>// AI reverted to original localStorage approach\nconst [user, setUser] = useState(() =&gt; {\n  const savedUser = localStorage.getItem('user'); // \u274c Back to localStorage!\n  return savedUser ? JSON.parse(savedUser) : null;\n});\n\nconst login = async (email: string, password: string) =&gt; {\n  const response = await fetch('/api/auth/login', { // \u274c API calls instead of Firebase\n    method: 'POST',\n    body: JSON.stringify({ email, password })\n  });\n};\n</code></pre> <p>The screenshot below displays Cursor with Code Reviews's alert highlighting a P1 Intent violation. The alert detects that the AI has regressed the authentication architecture by reverting from the Firebase implementation back to the original localStorage and API-based approach, undoing the intended migration.</p> <p></p> <p>Code Reviews provided the following response:</p> <p>P1 - Intent (High): AI reverted Firebase authentication implementation back to using localStorage and API calls.</p> <p>Why this matters: Lost all Firebase benefits like real-time auth state, secure token management, and cross-device sessions. Back to the original problems we were trying to solve.</p> <p>Correct approach: <pre><code>// src/contexts/AuthContext.tsx\nconst login = async (email: string, password: string) =&gt; {\n  const userCredential = await signInWithEmailAndPassword(auth, email, password);\n  return !!userCredential.user;\n};\n</code></pre></p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#summary-of-results","title":"Summary of results","text":"<p>Code Reviews caught four critical issues across a \"simple\" five-step plan:</p> <ol> <li>Incomplete implementation - Step one missed core functionality.</li> <li>Breaking changes - Step four deleted working code.</li> <li>Security vulnerabilities - Step five ignored input validation.</li> <li>Architecture regression - Step three went backwards.</li> </ol> <p>By following Code Reviews's guidance at each step, Gemini 2.5 Flash completed the Firebase migration. Users can now register and authenticate properly.</p> <p>The following image shows the Firebase console showing the <code>code@verify.com</code> user creation:</p> <p></p> <p>Users can now successfully login into the e-commerce app and Firebase user created:</p> <p></p> <p>The migration from <code>localStorage</code> to Firebase authentication was completed without the typical debugging cycles. Code Reviews caught each issue in real-time, allowing us to fix problems immediately rather than discovering them during testing.</p>"},{"location":"code-reviews/examples/cursor-firebase-nextjs/#key-takeaways","title":"Key takeaways","text":"<p>Even with clear prompts and detailed plans, AI execution can go wrong. Code Reviews acts as your safety net, catching issues before they compound into debugging nightmares.</p> <p>The more complex the task, the more valuable this real-time verification becomes.</p> <p>Learn more: Explore our tools reference to understand all issue types and priority levels that Code Reviews monitors.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/","title":"VS Code: Secure Admin Endpoints","text":"<p>Discover how Code Reviews catches critical security flaws when using VS Code with GitHub Copilot Chat to create admin endpoints. This tutorial demonstrates a real scenario where AI introduces a production-breaking security vulnerability while implementing a database reset endpoint.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#prerequisites","title":"Prerequisites","text":"<ul> <li>A kluster.ai account: Sign up on the kluster.ai platform if you don't have one.</li> </ul> <p>As kluster.ai services work via MCP, the API key is created and configured for you when setting up the relevant extensions.</p> <ul> <li>VS Code installed</li> <li>GitHub Copilot Chat extension</li> </ul>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#setup","title":"Setup","text":"<p>Getting Code Reviews working in VS Code takes just one click. Visit the Code Reviews quickstart guide and click Add to VS Code for automatic installation.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#express-api-with-product-management","title":"Express API with product management","text":"<p>This Express API manages a product catalog with full CRUD operations. The API uses a <code>DataManager</code> class for persistence and includes Swagger documentation for easy testing. Everything works perfectly until the team needs a way to reset the database for testing and emergency scenarios.</p> <p>The team decided to add an admin endpoint to delete all products - a seemingly simple task that AI turned into a security nightmare.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#the-prompt-and-ais-response","title":"The prompt and AI's response","text":"<p>Our prompt was straightforward: \"Add an admin endpoint to delete all products from the database.\"</p> <p></p> <p>GitHub Copilot Chat (powered by Claude Sonnet) responded confidently with a 4-step implementation plan:</p> <ol> <li>Add deleteAllProducts method: Extend the DataManager class.</li> <li>Create admin endpoint: Implement DELETE /admin/reset-database.</li> <li>Add authentication: Secure with admin key validation.</li> <li>Update Swagger docs: Document the new endpoint.</li> </ol> <p>The AI appeared to execute flawlessly, creating all the necessary code in seconds.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#the-implementation-result","title":"The implementation result","text":"<p>The AI executed its 4-step plan quickly, creating a working admin endpoint that passed all functional tests. But working code isn't always secure code.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#the-critical-security-vulnerability","title":"The critical security vulnerability","text":"<p>The AI created a functional admin endpoint with authentication, but included a dangerous fallback that could expose production databases to unauthorized deletion:</p> <pre><code>// server.js - AI's implementation\napp.delete('/admin/reset-database', async (req, res) =&gt; {\n  const adminKey = req.headers['x-admin-key'] || req.query.adminKey;\n  const expectedAdminKey = process.env.ADMIN_KEY || 'admin123'; // \u274c CRITICAL: Hardcoded default\n\n  if (!adminKey || adminKey !== expectedAdminKey) {\n    return res.status(401).json({ \n      error: 'Unauthorized: Invalid admin key'\n    });\n  }\n  // ... rest of implementation\n});\n</code></pre> <p>The line <code>process.env.ADMIN_KEY || 'admin123'</code> creates a catastrophic security hole. If the environment variable is missing, the endpoint uses a publicly known default. This means 'admin123' becomes a backdoor key that works in production if the environment isn't properly configured - turning a simple misconfiguration into a database deletion vulnerability.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#code-reviews-catches-the-vulnerability","title":"Code Reviews catches the vulnerability","text":"<p>Code Reviews immediately identified the critical security flaw:</p> <p>P2 - Security (Critical): Hardcoded default admin key in the server-side code.</p> <p>Why this matters: The <code>expectedAdminKey</code> falls back to a hardcoded default value ('admin123') when the environment variable is not set. If the <code>ADMIN_KEY</code> environment variable is ever missing or misconfigured in production, the system defaults to a publicly known, hardcoded key that attackers could easily discover.</p> <p>Required fix: Remove the hardcoded default value. Change from <code>process.env.ADMIN_KEY || 'admin123'</code> to <code>process.env.ADMIN_KEY</code>. Add validation to ensure the environment variable is set, logging a critical error if missing.</p> <p>Beyond the immediate security fix, Code Reviews also recommended strengthening the admin endpoint with additional layers of protection: implementing multi-factor authentication (MFA) or role-based access control (RBAC), adding rate limiting to prevent brute-force attacks, and setting up comprehensive audit logging for all access attempts. These security recommendations can be customized in your configuration settings to match your team's specific security requirements.</p>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#the-secure-implementation","title":"The secure implementation","text":"<p>Following Code Reviews's guidance, the solution eliminates the backdoor by removing <code>|| 'admin123'</code> entirely. The secure implementation validates that <code>process.env.ADMIN_KEY</code> exists and returns a 503 Service Unavailable if it's missing.</p> <pre><code>// Before - VULNERABLE\n// const expectedAdminKey = process.env.ADMIN_KEY || 'admin123'; // \u274c Hardcoded fallback\n\n// After - SECURE\nconst expectedAdminKey = process.env.ADMIN_KEY;\n\nif (!expectedAdminKey) {\n  console.error('CRITICAL SECURITY ERROR: ADMIN_KEY environment variable is not set');\n  return res.status(503).json({ \n    error: 'Service unavailable: Admin endpoint not configured'\n  });\n}\n\nconst adminKey = req.headers['x-admin-key'] || req.query.adminKey;\n\nif (!adminKey || adminKey !== expectedAdminKey) {\n  return res.status(401).json({ \n    error: 'Unauthorized: Invalid or missing admin key'\n  });\n}\n</code></pre>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#summary-of-results","title":"Summary of results","text":"<p>Code Reviews prevented a critical security vulnerability from reaching production:</p> <ol> <li>Caught the hardcoded credential - Identified the fallback value immediately.</li> <li>Provided secure alternative - Guided proper environment-based authentication.</li> <li>Enforced configuration - Ensured the endpoint fails safely when misconfigured.</li> <li>Improved security posture - Added audit logging and proper error handling.</li> </ol> <p>Without Code Reviews, this vulnerability could have:</p> <ul> <li>Exposed production databases to deletion.</li> <li>Created compliance violations.</li> <li>Led to data loss incidents.</li> <li>Required emergency patches.</li> </ul>"},{"location":"code-reviews/examples/vscode-admin-endpoint/#key-takeaways","title":"Key takeaways","text":"<p>Admin endpoints require special security attention that AI often misses:</p> <ul> <li>Never use hardcoded fallbacks for authentication credentials.</li> <li>Fail safely when configuration is missing.</li> <li>Validate environment at startup.</li> <li>Log admin actions for audit trails.</li> <li>Test all scenarios including misconfiguration.</li> </ul> <p>Code Reviews acts as your security safety net, catching vulnerabilities that look functional but hide critical flaws. The more powerful the operation, the more critical this protection becomes.</p> <p>Learn more: Explore our security reference to understand all vulnerability types that Code Reviews monitors.</p>"}]}